
/// /////////////////////////////////////////////////////// ///
/// ///////// AES ALGORITHM IMPLEMENTATION IN C++ ///////// ///
/// /////////////////////////////////////////////////////// ///
/// /////// Alejandra Velasco Sánchez-Villares //////////// ///
/// /////////////////////////////////////////////////////// ///

#include <iostream>
#include <cstring>
#include <fstream>
#include <sstream>
#include <string>

using namespace std;

// LOOK-UP TABLES //
unsigned char s[256] =// Substitution Table
{
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};
unsigned char mul2[] =// Multiplication Table 2
{
	0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
};
unsigned char mul3[] =// Multiplication Table 3
{
	0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
};
unsigned char rcon[256] = {// RCon vectors
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
};

/// ////////////////////////////////////////////////////////////////// ///
/// /// DEFINITION OF FUNCTIONS COMPOSING THE ENCRYPTION ALGORITHM /// ///
/// ////////////////////////////////////////////////////////////////// ///
/**

    AddRoundKey Function : XOR between the 128 bits of the message and the 128 bits of the key.
        Input : message, key.

**/
void AddRoundKey(unsigned char * message, unsigned char * roundKey) {
	for (int i = 0; i < 16; i++) {
		message[i] ^= roundKey[i];
	}
}
/**

    SubBytesMessage Function : substitutes each byte of the message for values in the Look-Up Table s.
        Input : message.

**/
void SubBytesMessage(unsigned char * message) {
	for (int i = 0; i < 16; i++) {
		message[i] = s[message[i]];
	}
}
/**

    ShiftRows Function : Rotates x bytes right in each row of the message.
        Input : message.

**/
void ShiftRows(unsigned char * message) {
	unsigned char tmp[16];
/// First Row : x = 0 (no changes)
    tmp[0] = message[0];
    tmp[4] = message[4];
    tmp[8] = message[8];
    tmp[12] = message[12];
/// Second Row : x = 1 (1 byte rotation)
    tmp[1] = message[13];
    tmp[5] = message[1];
    tmp[9] = message[5];
    tmp[13] = message[9];
/// Third Row : x = 2 (2 bytes rotation)
    tmp[2] = message[10];
    tmp[6] = message[14];
    tmp[10] = message[2];
    tmp[14] = message[6];
/// Fourth Row : x = 2 (2 bytes rotation)
    tmp[3] = message[7];
    tmp[7] = message[11];
    tmp[11] = message[15];
    tmp[15] = message[3];
/// We change the message.
    for (int i = 0; i < 16; i++)
        message[i] = tmp[i];
}
/**

    MixColumns Function : multiplies by columns the message with the Look-Up Tables mul2 and mul3.
        Input : message.

**/
void MixColumns(unsigned char * message) {
	unsigned char tmp[16];
/// First Column Calculation
	tmp[0] = (unsigned char) mul2[message[0]] ^ mul3[message[1]] ^ message[2] ^ message[3];
	tmp[1] = (unsigned char) message[0] ^ mul2[message[1]] ^ mul3[message[2]] ^ message[3];
	tmp[2] = (unsigned char) message[0] ^ message[1] ^ mul2[message[2]] ^ mul3[message[3]];
	tmp[3] = (unsigned char) mul3[message[0]] ^ message[1] ^ message[2] ^ mul2[message[3]];
/// Second Column Calculation
	tmp[4] = (unsigned char)mul2[message[4]] ^ mul3[message[5]] ^ message[6] ^ message[7];
	tmp[5] = (unsigned char)message[4] ^ mul2[message[5]] ^ mul3[message[6]] ^ message[7];
	tmp[6] = (unsigned char)message[4] ^ message[5] ^ mul2[message[6]] ^ mul3[message[7]];
	tmp[7] = (unsigned char)mul3[message[4]] ^ message[5] ^ message[6] ^ mul2[message[7]];
/// Third Column Calculation
	tmp[8] = (unsigned char)mul2[message[8]] ^ mul3[message[9]] ^ message[10] ^ message[11];
	tmp[9] = (unsigned char)message[8] ^ mul2[message[9]] ^ mul3[message[10]] ^ message[11];
	tmp[10] = (unsigned char)message[8] ^ message[9] ^ mul2[message[10]] ^ mul3[message[11]];
	tmp[11] = (unsigned char)mul3[message[8]] ^ message[9] ^ message[10] ^ mul2[message[11]];
/// Fourth Column Calculation
	tmp[12] = (unsigned char)mul2[message[12]] ^ mul3[message[13]] ^ message[14] ^ message[15];
	tmp[13] = (unsigned char)message[12] ^ mul2[message[13]] ^ mul3[message[14]] ^ message[15];
	tmp[14] = (unsigned char)message[12] ^ message[13] ^ mul2[message[14]] ^ mul3[message[15]];
	tmp[15] = (unsigned char)mul3[message[12]] ^ message[13] ^ message[14] ^ mul2[message[15]];
/// We change the message.
	for (int i = 0; i < 16; i++) {
		message[i] = tmp[i];
	}
}
/*
 * NOTE: the last two defined functions were implemented to create diffusion,e.g. to dissolve properties of the input message.
 */
/**

    Round Function : Executes all the Functions of an Intermediate Round of the Algorithm.
        Input: message, key

**/
void Round(unsigned char * message, unsigned char * key) {
	SubBytesMessage(message);
	ShiftRows(message);
	MixColumns(message);
	AddRoundKey(message, key);
}
/**

    Round Function : Executes all the Functions of the Final Round of the Algorithm.
        Input: message, key

**/
void FinalRound(unsigned char * message, unsigned char * key) {
	SubBytesMessage(message);
	ShiftRows(message);
	AddRoundKey(message, key);
}

/// //////////////////////////////////////////////////////////////////// ///
/// /// DEFINITION OF FUNCTIONS COMPOSING THE KEY EXPANSION FUNCTION /// ///
/// //////////////////////////////////////////////////////////////////// ///
/**

    RotWord Function : Rotates up by one byte the last column of the key.
        Input : key.

**/
 void RotWord(unsigned char * column) {
    unsigned char okey[4];
	okey[0]=column[1];
	okey[1]=column[2];
	okey[2]=column[3];
	okey[3]=column[0];
	for (int i = 0; i < 4; i++) {
		column[i] = okey[i];
	}
}
/**

    SubBytesKey Function : substitutes each byte of a column for values in the Look-Up Table s.
        Input : key.

**/
void SubBytesKey(unsigned char * column) {
	for (int i = 0; i < 4; i++) {
		column[i] = s[column[i]];
	}
}
/**

    ColumnSums Function: sums the first column of the key to a column.
        Input: column, key.

**/
void ColumnSums(unsigned char * column, unsigned char * key) {
	unsigned char okey[4];
	for (int i = 0; i < 4; i++) {
		okey[i] = column[i+1];
	}
	okey[0] = key[0] ^ column[0];
	okey[1] = key[1] ^ column[1];
	okey[2] = key[2] ^ column[2];
	okey[3] = key[3] ^ column[3];
	for (int i = 0; i < 4; i++) {
		column[i] = okey[i];
	}
}
/**

    RCon Function: XOR the sum of a column with an RCon vector.
        Input: key.

**/
void RCon(unsigned char * column) {
	unsigned char okey[4];
    int iRCon = 0; // To keep track of the RCon vector.
	for (int i = 0; i < 4; i++) {
		okey[i] = column[i] ^ rcon[i];
        column[i] = okey[i];

	}
}

/// ////////////////////////////// ///
/// /// KEY EXPANSION FUNCTION /// ///
/// ////////////////////////////// ///
/**

    KeyExpansion Function: changes the key and stores it with the preceding ones.
        Composed by
        Input: key, keys

**/
void KeyExpansion(unsigned char * key, unsigned char newKey[16]) {
/// Definition of variables to keep track of iterations.
	int ibytes = 16; // Number of bytes of keys that have already been generated.
/// Definition of variables to store information.
	unsigned char column[4]; // Were we will store the first column of the new key.
	unsigned char keys[176]; // Where we will store the new key with the preceding keys.

/// We will use this function until having created 10 keys, when we would have stored 11 keys.
	while (ibytes < 176) {
		for (int i = 0; i < 4; i++) { // We pick up the last column of the current key.
			column[i] = key[i+12];
		}
		if (ibytes % 16 == 0) { // We apply all the operations to this column.
			RotWord(column);
			SubBytesKey(column);
			ColumnSums(column, key);
            RCon(column);
		}
		unsigned char temporal[16]; // Were we will store the new key temporarily.
		for (int i = 0; i < 4; i++) { // We add the column of the new key to the new key and to the list of keys.
            temporal[i]=column[i];
            newKey[i]=column[i];
            keys[i + ibytes + 1] = column[i];
            ibytes++;
        }
/// We create the rest of the columns of the new key by a XOR of these and the old key's columns.
        for (unsigned char i = 0; i < 3; i++) {
			keys[i + ibytes +1] =  temporal[i] ^ key[4 + i];
			newKey[4 + i] = temporal[i] ^ key[4 + i];
			ibytes++;
        }
    }
}

/// //////////////////////////////// ///
/// /// AES ENCRYPTION ALGORITHM /// ///
/// //////////////////////////////// ///
/**

    AES Encryption: executes all the functions above defined.
        Input: message, key.

**/
void AESEncryption(unsigned char * plaintext, unsigned char * newKey, unsigned char * encryption) {
	unsigned char message[16];
	for (int i = 0; i < 16; i++) { // We store the first 16 bytes of the original message.
		message[i] = plaintext[i];
	}
	int numberOfRounds = 9; // Number of Intermediate Rounds.
	AddRoundKey(message, newKey); // Execute Initial Round.
	for (int i = 0; i < numberOfRounds; i++) { // Execute Intermediate Rounds.
		Round(message, newKey);
	}
	FinalRound(message, newKey); // Final Round.
	for (int i = 0; i < 16; i++) { // Transmit values.
		encryption[i] = message[i];
	}
}

int main() {

    unsigned char plaintext[16];
	unsigned char key[16];
	unsigned char encryption[16];

	cout << "Enter the message and key to encrypt: ";

	unsigned char keys[176];
	unsigned char *ukey = (unsigned char*)&key;

	for (int i = 0; i < 16; i += 16) {
		AESEncryption(plaintext, key, encryption);
	}
	cout << encryption << endl;
	// Free memory
	return 0;
}
